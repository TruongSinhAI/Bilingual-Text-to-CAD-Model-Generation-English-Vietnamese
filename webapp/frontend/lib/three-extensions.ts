import * as THREE from "three"

// STL Exporter for export functionality
export class STLExporter {
  parse(scene: THREE.Object3D, options: any = {}) {
    const binary = options.binary !== undefined ? options.binary : false

    const objects: THREE.Mesh[] = []
    scene.traverse((child) => {
      if (child instanceof THREE.Mesh) {
        objects.push(child)
      }
    })

    if (binary) {
      return this.parseBinary(objects)
    } else {
      return this.parseASCII(objects)
    }
  }

  parseASCII(objects: THREE.Mesh[]) {
    let output = "solid exported\n"

    objects.forEach((object) => {
      const geometry = object.geometry
      const matrixWorld = object.matrixWorld

      if (geometry.isBufferGeometry) {
        const vertices = geometry.attributes.position
        const normals = geometry.attributes.normal
        const indices = geometry.index

        if (indices !== null) {
          for (let i = 0; i < indices.count; i += 3) {
            const a = indices.getX(i)
            const b = indices.getX(i + 1)
            const c = indices.getX(i + 2)

            this.writeTriangle(output, vertices, normals, a, b, c, matrixWorld)
          }
        } else {
          for (let i = 0; i < vertices.count; i += 3) {
            this.writeTriangle(output, vertices, normals, i, i + 1, i + 2, matrixWorld)
          }
        }
      }
    })

    output += "endsolid exported\n"
    return output
  }

  parseBinary(objects: THREE.Mesh[]) {
    let triangles = 0

    objects.forEach((object) => {
      const geometry = object.geometry
      if (geometry.isBufferGeometry) {
        const indices = geometry.index
        if (indices !== null) {
          triangles += indices.count / 3
        } else {
          triangles += geometry.attributes.position.count / 3
        }
      }
    })

    const bufferLength = 80 + 4 + triangles * 50
    const arrayBuffer = new ArrayBuffer(bufferLength)
    const view = new DataView(arrayBuffer)

    // Header (80 bytes)
    const header = "STL generated by three.js"
    for (let i = 0; i < 80; i++) {
      view.setUint8(i, i < header.length ? header.charCodeAt(i) : 0)
    }

    // Number of triangles (4 bytes)
    view.setUint32(80, triangles, true)

    let offset = 84

    objects.forEach((object) => {
      const geometry = object.geometry
      const matrixWorld = object.matrixWorld

      if (geometry.isBufferGeometry) {
        const vertices = geometry.attributes.position
        const normals = geometry.attributes.normal
        const indices = geometry.index

        if (indices !== null) {
          for (let i = 0; i < indices.count; i += 3) {
            const a = indices.getX(i)
            const b = indices.getX(i + 1)
            const c = indices.getX(i + 2)

            offset = this.writeBinaryTriangle(view, offset, vertices, normals, a, b, c, matrixWorld)
          }
        } else {
          for (let i = 0; i < vertices.count; i += 3) {
            offset = this.writeBinaryTriangle(view, offset, vertices, normals, i, i + 1, i + 2, matrixWorld)
          }
        }
      }
    })

    return arrayBuffer
  }

  writeTriangle(
    output: string,
    vertices: THREE.BufferAttribute,
    normals: THREE.BufferAttribute,
    a: number,
    b: number,
    c: number,
    matrixWorld: THREE.Matrix4,
  ) {
    const vA = new THREE.Vector3().fromBufferAttribute(vertices, a).applyMatrix4(matrixWorld)
    const vB = new THREE.Vector3().fromBufferAttribute(vertices, b).applyMatrix4(matrixWorld)
    const vC = new THREE.Vector3().fromBufferAttribute(vertices, c).applyMatrix4(matrixWorld)

    const nA = normals
      ? new THREE.Vector3()
          .fromBufferAttribute(normals, a)
          .applyMatrix3(new THREE.Matrix3().getNormalMatrix(matrixWorld))
      : new THREE.Vector3()

    output += `  facet normal ${nA.x} ${nA.y} ${nA.z}\n`
    output += "    outer loop\n"
    output += `      vertex ${vA.x} ${vA.y} ${vA.z}\n`
    output += `      vertex ${vB.x} ${vB.y} ${vB.z}\n`
    output += `      vertex ${vC.x} ${vC.y} ${vC.z}\n`
    output += "    endloop\n"
    output += "  endfacet\n"

    return output
  }

  writeBinaryTriangle(
    view: DataView,
    offset: number,
    vertices: THREE.BufferAttribute,
    normals: THREE.BufferAttribute,
    a: number,
    b: number,
    c: number,
    matrixWorld: THREE.Matrix4,
  ) {
    const vA = new THREE.Vector3().fromBufferAttribute(vertices, a).applyMatrix4(matrixWorld)
    const vB = new THREE.Vector3().fromBufferAttribute(vertices, b).applyMatrix4(matrixWorld)
    const vC = new THREE.Vector3().fromBufferAttribute(vertices, c).applyMatrix4(matrixWorld)

    const nA = normals
      ? new THREE.Vector3()
          .fromBufferAttribute(normals, a)
          .applyMatrix3(new THREE.Matrix3().getNormalMatrix(matrixWorld))
      : new THREE.Vector3()

    // Normal (12 bytes)
    view.setFloat32(offset, nA.x, true)
    view.setFloat32(offset + 4, nA.y, true)
    view.setFloat32(offset + 8, nA.z, true)
    offset += 12

    // Vertices (36 bytes)
    view.setFloat32(offset, vA.x, true)
    view.setFloat32(offset + 4, vA.y, true)
    view.setFloat32(offset + 8, vA.z, true)
    offset += 12

    view.setFloat32(offset, vB.x, true)
    view.setFloat32(offset + 4, vB.y, true)
    view.setFloat32(offset + 8, vB.z, true)
    offset += 12

    view.setFloat32(offset, vC.x, true)
    view.setFloat32(offset + 4, vC.y, true)
    view.setFloat32(offset + 8, vC.z, true)
    offset += 12

    // Attribute byte count (2 bytes)
    view.setUint16(offset, 0, true)
    offset += 2

    return offset
  }
}
